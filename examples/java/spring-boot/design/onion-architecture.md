# Onion Architecture

We have [decided to structure our application using an approach called Onion Architecture](../../../../adr/0005-onion-architecture.md). 

The classes in this reference implementation are split into four packages, each of which represents a layer in the Onion Architecture model:

- infrastructure
- application
- domain.service
- domain.model

![Diagram for onion architecture layers](https://kroki.io/plantuml/svg/eNptz8FKA0EMBuD7PkXoA0i3KJ4rInhuXyDMZrdhZ5IhySoovrsWoQSU3PKFP4mvLB0NGzQVLRfTRhC20eA3MZTVqcNhn5pTZxgfcgfN9P184bIKucP-7jFhx7LiQmeOSsfKizSSgEpzpKHNqaDTk9pElpPu82KacavxohIn_iAYD_lUKoGy1D8Z4zDcDHavMhv6z5slNqMdfA4AiY-9Vy4YrHK1JM_akAWc7I0L_Y9NJ6pX-vqtb3nZf68=)

The exception is the Application class, which is at the top level. This class in is still part of the `@ApplicationServiceRing`, but we've left it as a top level class to retain Spring Boot's autoconfiguration and to avoid us requiring integration tests to use `@ContextConfiguration` to autoconfigure, or to specify the `scanBasePackages`.

Anything can depend on something from an inner rings, and inner rings don't know anything about outer layers.

This allows us to think about the domain and business logic separately from how we implement the infrastructure layer.

Below is a class diagram generated from our codebase, showing how the classes in each package relate to each other:

![PlantUML Diagram for spring boot application](http://www.plantuml.com/plantuml/svg/tLXVR-8u47ycdoAFGUr6wYjQeSq1UukkBJswvHvE9-Gc0tXnufpjSAhszhkVxH3iu6oRfha_kae5F7_6lvdvsKpum0LYeaY9n_Suon53gSztAA5_u6phRn3Xu7anGPpxnJxSqaE8SXpod4dr8wKYZFASu1W9J3F_g-VBltVlzDl5LowaEFxcfmXd0M9RFlBlXNByzRUXzytpSXJlqHQ-4nZL0dk3rjOX1tR0CN3fDXXKsDiwoOJmVVbP-mzaElBrmeW31ZdbM53sDFAbU7bQ3fLb66fx1Z9LE414I30S-TUOY_VIU2oLCdNr_s85SBPXY0jMnA9W4COqs-2j0bNbrDefl4dYZoX6IPcJQSraiLpEhgFFyyNjUZwj-kCTixw82I0M3DN7l1317fugaql_W4W1rNAeCke2R48p0PcuXIqLM7TYeXK5gpf_mbAtf2o87TyRbA4ji94_-PvgwEWewuwTCI0w-ZpvY8a0Pk5jq0R066LBu3dDE4mXfapjF_9dZV9BFwtQDl9F7UnSwiPDRCJD1a5M5Sgjgy987xz0B6vGdgl2BwpLq3kUXeka30Q_OB6pUX8m-Bq0BaR-9o5oTRm8Y6Kfk_JP4ScPjXHU-hgMK-0nmxaAPgZOvN2TpZG6xXonzgxXBCt5K-rIi0gymLdYtWSTqAOq0SB350HAa43XuGgHV8SSu9sYg1jGzPbHGcgChic3uuKvyitDA2-5gqY5gDYmCaj31-Tk_A4W-viZYAg_gYoz93EL2ok7BOWeIR0Y329tZ4fS0WDNC2JAzyVBhMJn-EYWaaQnK3QbNicvaSVbkqL0xMPnqt6rTOdvx8IWSP62ZAwK3qnNws4vBuEuskHCe8shMBSe1GU75cRovNpd1TkY37FKXBwkf6RXu7SWAq5H0JlnGPvuH7X0nSvS8T9Djfa0ofJ53l7TX2Ow0Po9CfhRoISh5_CTLKLKNeAMEfDJRqohNPzroccLsh9cKtheN2eJKA-DPaCxr7FKSWoUkIYxrl-vIa9Mf3qMibpfSivlLz7rVBfUpdv-cDr_hWfiffaDe-bAjJoe3IVDTM_EGKcryzz0aAPxxerNKvJZ5J1-v47J1g4nAGbY-w3JnnUTXsP7Rd-1LIvZ4vshkBp1vDy_yRtoz8MAwTP6T_FrZulL-k6dzMfzjOwkxpv5hOdRegN_E8cjVlRANIjkQyes-vo-FALOHLRlPPnIfCnBwV-CZsuvUgEX7Re3-xeDkNfgR3MDkrvXRVIiFqOUW0d58vrMFRbsG1EgVj8e-z0ChzbMbQu-JrjqDfofCyWP3vMmOCGixFbJ2zoHJ4cTwT2P0moOUZVZfW6umkLOd-zZQyr9U_pI-fnbpkHg9rZNDDEnOEJykBNliFDiE92uW6rG_6hlq7qor5nmdmtTtugw_OGLXkEMnFHwUTWDmp_7RwjANpYwvztvMLdjslz8uVKtJByTODCWtM_6Bip-HxF_8cJxMwYlGBsYwgr-lGBKqrttoQ3_Yw9fbzxPqVrwVKt27o1BYfJy1G00)

The models generated by our JSON Schema definitions, used for the  HTTP layer, are in the infrastructure layer.

None of the classes in the domain layer use Spring, as these classes are entirely separate from the framework. 
